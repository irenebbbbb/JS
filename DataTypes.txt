'number' + 3 + 3 
/* number33
Оператор + делает контатенацию (слияние) строковых значений.
Поскольку у нас первое строкове значение ('number'), числовые значения будут переведены в строковый тип данных (а не выполнять арифметическую операцию).
3 будет переведено в строковое значение "3", соответственно number33*/


null + 3
/*3
Оператор + с числовыми данными делает арифметическую операцию сложение. 
null при преобразовании в число превращается в 0, а 0 + 3 = 3*/


5 && "qwerty"
/*qwerty
Числовые и строковые операнды (непустая строка) являются значениями true,
если все значения true оператор возвращает последнее значение*/


+'40' + +'2' + "hillel";
/*42hillel
+ перед строковыми значениями переводит их в числовые
Соответственно в первой части получится 40 + 2
Если операция сложения начинается с чисел, эти числа будут суммироваться 40 + 2 = 42
Далее происходит контатенация (слияние) со строковым значением*/


'10' - 5 === 6; 
/*false
Строковое значение 10 в арифметической операции будет преобразовано в число 10, а 10 - 5 = 5
Оператор === определяет строгое равенство между значениями, учитывая типы данных, но в нашем уравнении оба значения числовые. 
5 не равно 6, соответственно результат false*/


true + false 
/*1
В математическом уравнении булевые значения преобразуются в числовые: true соответствует 1, false - 0, а 1 + 0 = 1*/


'4px' - 3
/*NaN
JS попытается преобразовать в матиматической операции '4px' в числовое значение, но не сможет, поскольку в нем содержаться буквы
Соответственно преобразование строки '4px' в число приведет к значению NaN
Результат NaN - 3 будет NaN*/


'4' - 3
/*1
В математической операции строковое значение 4 преобразуется в числовое 4, а 4 - 3 = 1*/


'6' + 3 ** 0; 
/*61
Сначала выполняем вторую операцию (по приоритетам операторов), а 3 в 0 степени равно 1. 
Поскольку 6 это строкове значение, + будет делать контатенацию (поскольку минимум один операнд строковый)
1 останется числом, соответственно "6" + 1 = 61*/


12 / '6'
/*2
Строковое значение 6 будет преобразовано в числовое значение 6 (операция / всегда пытается преобразовать строки в числа). 
А 12 / 6 = 2*/


'10' + (5 === 6); 
/*10false
Сначала выполняем операцию в скобках - числовое значение 5 не равно 6 (=== это строгое равно, учитывая тип данных), соответственно false. 
false в свою очередь не будет преобразовано в числовое значение 0, поскольку оператор + делает контатенацию, если одно из значений строковое. 
Соответственно слияние "10" + false будет 10false*/


null == ''
/*false
== проверяет равны ли значения
'' является пустой строкой, null это отсутствие значения
Пустая строка не равна null*/


3 ** (9 / 3); 
/*27
Сначала выполняем уравнение в скобках (9 / 3 = 3), 
а потом 3 превозносим в 3 степень (поскольку ** означает превознести в степень)*/


!!'false' == !!'true'
/*true
Поскольку непустые строки являются true, 
а оператор !! относительно true вернет true (преобразовывает значение к булевому значению), 
true == true*/


0 || '0' && 1 
/*1
По приоритету операторов сначала берется во внимание оператор &&. 
Строковое значение 0 является true значением (непустая строка).
1 соответствует значению true. 
Если оба значения true, && вернет второе значение 1.

Значения в выражении || (ИЛИ) 0=false и 1=true, 
соответственно оператор || (ИЛИ) берет первое значение true 1*/


(+null == false) < 1; 
/*false
Поскольку +null будет преобразовано в 0 (+ перед значением пытается преобразовать его в числовое, а null соответствует 0),
0 равен false (поскольку в уравнении false будет преобразован в 0), 
0 == 0, то есть true, 
а в уравнении 1 равно 1, а не меньше его*/


false && true || true 
/*true
false && true это false (поскольку false не является true значением, а для результата выражения true оба значения должны быть true), 
а в выражении true или false значение true, если хотя бы одно из условий является true берется первое значение true*/


false && (false || true); 
/*false
В скобках результат будет true (первое значение true, если хотя бы одно значение true), 
а в выражении && оба условия должны быть true, чтобы результат был true*/


(+null == false) < 1 ** 5; 
/*false
+null будет преобразовано в числовое значение 0, что является равно false 
(поскольку логическое уравнение приводит значения к числовым, а false соответствует 0), 
а 0 == 0, соответственно true. 
При преобразовании в числовое значение true станет 1.

Далее будет выполнено сравнение, посколько операторы сравнения имеют приоритет перед возведением в степень.
1 (true) является равным 1, а не меньше его, соответственно false
false будет преобразовано в 0, а 0 в 5 степени равно 0
Результат 0, что соответствует false*/